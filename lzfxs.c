/*
 * SPDX-License-Identifier: BSD-2-Clause
 *
 * lzfxs.c  --  LZFXS compression / decompression algorithm
 *
 * Copyright (c) 2000-2008 Marc Alexander Lehmann <schmorp@schmorp.de>
 * Copyright (c) 2009 Andrew Collette <andrew.collette@gmail.com>
 * Copyright (c) 2023 Jeffrey H. Johnson <trnsz@pobox.com>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   1.  Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *   2.  Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "lzfxs.h"

#define LZFXS_HSIZE  ( 1 << ( LZFXS_HLOG ) )

/* We need this for memset */
#ifdef __cplusplus
# include <cstring>
#else
# include <string.h>
#endif /* ifdef __cplusplus */

#if __GNUC__ >= 3
# define fx_expect_false(expr)   __builtin_expect(( expr ) != 0, 0)
# define fx_expect_true(expr)    __builtin_expect(( expr ) != 0, 1)
#else
# define fx_expect_false(expr)   ( expr )
# define fx_expect_true(expr)    ( expr )
#endif /* if __GNUC__ >= 3 */

typedef unsigned char u8;
typedef const u8 *LZSTATE[LZFXS_HSIZE];

/* Define the hash function */
#define LZFXS_FRST(p)      (((  p[0] ) << 8 ) | p[1] )
#define LZFXS_NEXT(v, p)   (((  v    ) << 8 ) | p[2] )
#define LZFXS_IDX(h)       (((( h    ) >> ( 3 * 8 - LZFXS_HLOG )) - ( h ) ) \
                               & ( LZFXS_HSIZE - 1 ))

/* These cannot be changed, as they are related to the compressed format. */
#define LZFXS_MAX_LIT    ( 1 << 5 ) - 1
#define LZFXS_MAX_OFF    ( 1 << 13 )
#define LZFXS_MAX_REF   (( 1 << 8 ) + ( 1 << 3 ) - 2 )

static int lzfxs_getsize(const void *ibuf, unsigned int ilen,
                         unsigned int *olen);

/*
 * Compressed format
 *
 * There are two kinds of structures in LZFXS: literal runs and back
 * references.  Literals are encoded as follows:
 *
 * LLLLL000 <L bytes>
 *
 * Back references are encoded as follows.  The smallest possible encoded
 * length value is 1, as otherwise the control byte would be recognized as
 * a literal run.  At least three bytes must match for a back reference
 * to be inserted.  The offset (distance to the desired data in the output
 * buffer) is encoded as o - 1, as all offsets are at least 1.  The binary
 * format is:
 *
 * oooooLLL oooooooo           for backrefs of real length  < 7 (1 <= L < 7)
 * ooooo111 LLLLLLLL oooooooo  for backrefs of real length >= 7 (L >= 7)
 */

int
lzfxs_compress(const void *const ibuf, const unsigned int ilen, void *obuf,
               unsigned int *const olen)
{

  /*
   * Hash table; an array of u8*'s which point
   * to various locations in the input buffer
   */

  const u8 *       htab[LZFXS_HSIZE];
  const u8 **      hslot;  /* Pointer to entry in hash table               */
  unsigned int     hval;   /* Hash value generated by macros above         */
  int              lit;    /* # of bytes in current literal run            */
  const u8 *       ref;    /* Pointer to candidate match location in input */
  const u8 *       ip       = (const u8 *)ibuf;
  const u8 *const  in_end   = ip + ilen;
  u8 *             op       = (u8 *)obuf;
  const u8 *const  out_end  = ( olen == NULL ? NULL : op + *olen );

#if ( defined( WIN32 ) || defined( _WIN32) ) && defined( _M_X64 )
    unsigned _int64  off;  /* Workaround for missing POSIX types */
#else
    unsigned long    off;
#endif /* if ( defined( WIN32 ) || defined( _WIN32 ) ) && defined( _M_X64 ) */

  if (olen == NULL)
    {
      return LZFXS_EARGS;
    }

  if (ibuf == NULL)
    {
      if (ilen != 0)
        {
          return LZFXS_EARGS;
        }

      *olen = 0;
      return 0;
    }

  if (obuf == NULL)
    {
      return LZFXS_EARGS;
    }

  memset(htab, 0, sizeof ( htab ));

  /*
   * Start a literal run.  Whenever we do this the output pointer is
   * advanced because the current byte will hold the encoded length.
   */

  lit = 0;
  op++;

  hval = LZFXS_FRST(ip);

  while (ip + 2 < in_end)
    { /* The LZFXS_NEXT macro reads 2 bytes ahead */
      hval    = LZFXS_NEXT(hval, ip);
      hslot   = htab + LZFXS_IDX(hval);

      ref     = *hslot;
      *hslot  = ip;

      if (ref < ip && ( off = ip - ref - 1 ) < LZFXS_MAX_OFF
          && ip + 4 < in_end /* Backref takes up to 3 bytes, so don't bother */
          && ref > (u8 *)ibuf && ref[0] == ip[0] && ref[1] == ip[1]
          && ref[2] == ip[2])
        {
          unsigned int        len     = 3; /* We already know 3 bytes match */
	  const unsigned int  modlen  = in_end - ip - 2;
          const unsigned int  maxlen  = modlen > LZFXS_MAX_REF
                                          ? LZFXS_MAX_REF : modlen;

          /*
           * lit == 0: op + 3 must be < out_end (because we undo the run)
           * lit != 0: op + 3 + 1 must be < out_end
           */

          if (fx_expect_false(op - !lit + 3 + 1 >= out_end))
            {
              return LZFXS_ESIZE;
            }

          op[-lit - 1]  =  lit << 3; /* Terminate literal run      */
          op           -= !lit;      /* Undo run if length is zero */

          /* Start checking at the fourth byte */
          while (len < maxlen && ref[len] == ip[len])
            {
              len++;
            }

          if (len < 7)
            {
              /* Format 1: [oooooLLL oooooooo] */
              *op++  = (( off >> 8 ) << 3 ) + len;
              *op++  = off;
            }
          else
            {
              /* Format 2: [ooooo111 LLLLLLLL oooooooo] */
              *op++  = (( off >> 8 ) << 3 ) + 7;
              *op++  = len - 7;
              *op++  = off;
            }

          lit = 0;
          op++;

          ip += len - 1; /* ip = initial ip + #octets - 1 */

          if (fx_expect_false(ip + 3 >= in_end))
            {
              ip++; /* Code following expects exit at bottom of loop */
              break;
            }

          hval                   = LZFXS_FRST(ip);
          hval                   = LZFXS_NEXT(hval, ip);
          htab[LZFXS_IDX(hval)]  = ip;

          ip++; /* ip = initial ip + #octets */
        }
      else
        {
          /* Keep copying literal bytes */
          if (fx_expect_false(op >= out_end))
            {
              return LZFXS_ESIZE;
            }

          lit++;
          *op++ = *ip++;

          if (fx_expect_false(lit == LZFXS_MAX_LIT))
            {
              op[-lit - 1]  = lit << 3; /* stop run */
              lit           = 0;
              op++; /* start run */
            }
        } /* if() found match in htab */
    } /* while(ip < ilen -2) */

  /*
   * At most 3 bytes remain in input.
   * We therefore need 4 bytes available in the
   * output buffer to store them (3 data + ctrl byte).
   */

  if (op + 3 > out_end)
    {
      return LZFXS_ESIZE;
    }

  while (ip < in_end)
    {
      lit++;
      *op++ = *ip++;

      if (fx_expect_false(lit == LZFXS_MAX_LIT))
        {
          op[-lit - 1]  = lit << 3;
          lit           = 0;
          op++;
        }
    }

  op[-lit - 1]   = lit << 3;
  op            -= !lit;
  *olen          = op - (u8 *)obuf;
  return 0;
}

/* Decompressor */
int
lzfxs_decompress(const void *ibuf, unsigned int ilen, void *obuf,
                 unsigned int *olen)
{
  u8 const *       ip          = (const u8 *)ibuf;
  u8 const *const  in_end      = ip + ilen;
  u8 *             op          = (u8 *)obuf;
  u8 const *const  out_end     = ( olen == NULL ? NULL : op + *olen );
  unsigned int     remain_len  = 0;
  int              rc;

  if (olen == NULL)
    {
      return LZFXS_EARGS;
    }

  if (ibuf == NULL)
    {
      if (ilen != 0)
        {
          return LZFXS_EARGS;
        }

      *olen = 0;
      return 0;
    }

  if (obuf == NULL)
    {
      if (*olen != 0)
        {
          return LZFXS_EARGS;
        }

      return lzfxs_getsize(ibuf, ilen, olen);
    }

  do
    {
      unsigned int ctrl = *ip++;

      /* Format LLLLL000: a literal byte string follows, of length L */
      if (( ctrl & 0x7 ) == 0)
        {
          unsigned int len = ctrl >> 3;

          if (fx_expect_false(op + len > out_end))
            {
              --ip; /* Rewind to control byte */
              goto guess;
            }

          if (fx_expect_false(ip + len > in_end))
            {
              return LZFXS_ECORRUPT;
            }

          do
            {
              *op++ = *ip++;
            }
          while (--len);

          /*
           * Format #1 [oooooLLL oooooooo]: backref of length L+1
           *            ^^^^^    ^^^^^^^^
           *              A         B
           *
           * Format #2 [ooooo111 LLLLLLLL oooooooo] backref of length L+7
           *            ^^^^^             ^^^^^^^^
           *              A                  B
           *
           * In both cases the location of the backref is computed from the
           * remaining part of the data as follows:
           *
           *     location = op - A*256 - B - 1
           */

        }
      else
        {
          unsigned int  len  = ctrl & 0x7;
          u8 *          ref  = op - (( ctrl >> 3 ) << 8 ) - 1;

          if (len == 7)
            {
              len += *ip++; /* i.e. format #2 */
            }

          if (fx_expect_false(op + len > out_end))
            {
              ip -= ( len >= 7 ) ? 2 : 1; /* Rewind to control byte */
              goto guess;
            }

          if (fx_expect_false(ip >= in_end))
            {
              return LZFXS_ECORRUPT;
            }

          ref -= *ip++;

          if (fx_expect_false(ref < (u8 *)obuf))
            {
              return LZFXS_ECORRUPT;
            }

          do
            {
              *op++ = *ref++;
            }
          while (--len);
        }
    }
  while (ip < in_end);

  *olen = op - (u8 *)obuf;

  return 0;

 guess:
  rc = lzfxs_getsize(ip, ilen - ( ip - (u8 *)ibuf ), &remain_len);
  if (rc >= 0)
    {
      *olen = remain_len + ( op - (u8 *)obuf );
    }

  return rc;
}

/*
 * Guess len.
 * No parameters may be NULL.
 * XXX this is NOT checked here!
 */

static int
lzfxs_getsize(const void *ibuf, unsigned int ilen, unsigned int *olen)
{
  u8 const *       ip       = (const u8 *)ibuf;
  u8 const *const  in_end   = ip + ilen;
  int              tot_len  = 0;

  while (ip < in_end)
    {
      unsigned int ctrl = *ip++;

      if (( ctrl & 0x7 ) == 0)
        {
          if (ip + ( ctrl >> 3 ) > in_end)
            {
              return LZFXS_ECORRUPT;
            }

          tot_len  += ( ctrl >> 3 );
          ip       += ( ctrl >> 3 );
        }
      else
        {
          unsigned int len = ctrl & 0x7;

          if (len == 7)
            { /* i.e. format #2 */
              len += *ip++;
            }

          if (ip >= in_end)
            {
              return LZFXS_ECORRUPT;
            }

          ip++; /* skip the ref byte */

          tot_len += len;
        }
    }

  *olen = tot_len;

  return 0;
}
